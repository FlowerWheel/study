javascript grammar
==================

![javascript prototype](https://raw.githubusercontent.com/liuyanjie/js-core/master/javascript-syntax/images/javascript-prototype.png)



这几天在看《javascript高级程序设计》，看到执行环境和作用域链的时候，就有些模糊了。书中还是讲的不够具体。
通过上网查资料，特来总结，以备回顾和修正。

要讲的依次为：

    EC(执行环境或者执行上下文，Execution Context)
    ECS(执行环境栈Execution Context Stack)
    VO(变量对象，Variable Object)|AO(活动对象，Active Object)
    scope chain(作用域链)和[[scope]]属性

每当控制器到达ECMAScript可执行代码的时候，控制器就进入了一个执行上下文。

javascript中，EC分为三种：

    全局级别的代码 – 这个是默认的代码运行环境，一旦代码被载入，引擎最先进入的就是这个环境。
    函数级别的代码 – 当执行一个函数时，运行函数体中的代码。
    Eval的代码 – 在Eval函数内运行的代码。
    
EC建立分为两个阶段：进入执行上下文和执行阶段。

    1.进入上下文阶段：发生在函数调用时，但是在执行具体代码之前（比如，对函数参数进行具体化之前），也可以说是建立相关函数的上下文，为函数执行做准备。
    2.执行代码阶段：变量赋值，函数引用，执行其他代码。

我们可以将EC看做是一个对象。

    EC={
        VO:{
            // arguments
            // 参数
            // 内部变量
            // 函数声明
        },
        this:{
            
        },
        Scope:{
            // VO
            // 所有父执行上下文中的VO
        }
    }

一系列活动的执行上下文从逻辑上形成一个栈。栈底总是全局上下文，栈顶是当前（活动的）执行上下文。当在不同的执行上下文间切换（退出的而进入新的执行上下文）的时候，栈会被修改（通过压栈或者退栈的形式）。

    ECS压栈：全局EC-->局部EC1-->局部EC2-->当前EC
    ECS出栈：全局EC<--局部EC1<--局部EC2<--当前EC

我们可以用数组的形式来表示环境栈:

    ECS=[局部EC,全局EC];
    每次控制器进入一个函数（哪怕该函数被递归调用或者作为构造器），都会发生压栈的操作。

当javascript代码文件被浏览器载入后，默认最先进入的是一个全局的执行上下文。
当在全局上下文中调用执行一个函数时，程序流就进入该被调用函数内，此时引擎就会为该函数创建一个新的执行上下文，并且将其压入到执行上下文堆栈的顶部。
浏览器总是执行当前在堆栈顶部的上下文，一旦执行完毕，该上下文就会从堆栈顶部被弹出，然后，进入其下的上下文执行代码。
这样，堆栈中的上下文就会被依次执行并且弹出堆栈，直到回到全局的上下文。

### VO|AO

#### VO

每一个`EC`都包含一个`变量对象VO`，在该`EC`中定义的所有`变量`和`函数`都存放在其对应的`VO`中。

VO分为`全局上下文VO`（全局对象，Global object，global）和`函数上下文的AO`。

    VO: {
      // 函数形参（function arguments）)
      // 上下文中的数据 (变量声明、函数声明), 
    }
    
1.进入执行上下文时，VO的初始化过程具体如下：

    函数形参（当进入函数执行上下文时） —— 变量对象的一个属性，其属性名就是形参的名字，其值就是实参的值；对于没有传递的参数，其值为undefined。
    函数声明（FunctionDeclaration） —— 变量对象的一个属性，其属性名和值都是函数对象创建出来的；如果变量对象已经包含了相同名字的属性，则替换它的值。
    变量声明（VariableDeclaration） —— 变量对象的一个属性，其属性名即为变量名，其值为undefined；如果变量名和已经声明的函数名或者函数的参数名相同，则不会影响已经存在的属性。
    注意：该过程是有先后顺序的。

2.执行代码阶段时，VO中的一些属性undefined值将会确定。

#### AO

在函数的执行上下文中，VO是不能直接访问的。它主要扮演被称作活动对象AO（activeObject）的角色。
这句话怎么理解呢，就是当EC环境为函数时，我们访问的是AO，而不是VO。

VO(functionContext) === AO;
AO是在进入函数的执行上下文时创建的，并为该对象初始化一个arguments属性，该属性的值为Arguments对象。

    AO = {
      arguments: {
        callee:,
        length:,
        properties-indexes: // 函数传参参数值
      }
    };
    
FunctionDeclaration的形式只能是如下这样：

    function f(){
    
    }

